{"ast":null,"code":"const User = require('../models/user');\nconst bcrypt = require('bcrypt');\nconst jwt = require('jsonwebtoken');\nconst multer = require('multer');\nconst path = require('path');\n\n// Configuration de multer pour gérer les uploads\nconst storage = multer.diskStorage({\n  destination: function (req, file, cb) {\n    cb(null, 'uploads/'); // Dossier où les images seront stockées\n  },\n\n  filename: function (req, file, cb) {\n    cb(null, Date.now() + path.extname(file.originalname)); // Nom unique pour chaque fichier\n  }\n});\n\nconst upload = multer({\n  storage: storage\n});\nexports.register = [upload.single('profile'),\n// Middleware pour gérer l'upload de l'image de profil\nasync (req, res) => {\n  const {\n    name,\n    email,\n    password,\n    confirmPassword\n  } = req.body;\n\n  // Validation des champs\n  if (!name || !email || !password || !confirmPassword) {\n    return res.status(400).json({\n      message: 'Tous les champs sont requis'\n    });\n  }\n\n  // Validation des mots de passe\n  if (password !== confirmPassword) {\n    return res.status(400).json({\n      message: 'Les mots de passe ne correspondent pas'\n    });\n  }\n  try {\n    // Vérification si l'utilisateur existe déjà\n    let user = await User.findOne({\n      email: email.trim()\n    });\n    if (user) {\n      return res.status(400).json({\n        message: 'Utilisateur déjà existant'\n      });\n    }\n\n    // Hachage du mot de passe avant de sauvegarder l'utilisateur\n    const salt = await bcrypt.genSalt(10);\n    const hashedPassword = await bcrypt.hash(password.trim(), salt);\n\n    // Création d'un nouvel utilisateur\n    user = new User({\n      name,\n      email: email.trim(),\n      password: hashedPassword,\n      // Utilisation du mot de passe haché\n      profileImage: req.file ? req.file.filename : null // Stocke le nom du fichier de l'image de profil\n    });\n\n    await user.save();\n\n    // Génération du token JWT\n    const token = jwt.sign({\n      userId: user._id\n    }, process.env.JWT_SECRET, {\n      expiresIn: '1h'\n    });\n    res.status(201).json({\n      token,\n      message: 'Inscription réussie'\n    });\n  } catch (error) {\n    console.error(error.message);\n    res.status(500).json({\n      message: 'Erreur serveur'\n    });\n  }\n}];\nexports.login = async (req, res) => {\n  try {\n    console.log('Données reçues pour la connexion:', req.body); // Log les données reçues\n\n    const {\n      email,\n      password\n    } = req.body;\n\n    // Vérifier si l'utilisateur existe\n    const user = await User.findOne({\n      email: email.trim()\n    });\n    console.log('Utilisateur trouvé:', user); // Log l'utilisateur trouvé\n\n    if (!user) {\n      return res.status(400).json({\n        message: \"Email incorrect\"\n      });\n    }\n\n    // Vérifier si le mot de passe est correct\n    const isMatch = await bcrypt.compare(password.trim(), user.password);\n    console.log('Résultat de la comparaison du mot de passe:', isMatch); // Log le résultat de la comparaison\n\n    if (!isMatch) {\n      return res.status(400).json({\n        message: \"Mot de passe incorrect\"\n      });\n    }\n\n    // Générer un token JWT pour l'utilisateur authentifié\n    const token = jwt.sign({\n      userId: user._id\n    }, process.env.JWT_SECRET, {\n      expiresIn: '1h'\n    });\n    res.status(200).json({\n      message: \"Login réussi\",\n      token\n    });\n  } catch (err) {\n    console.error('Erreur lors de la connexion:', err);\n    res.status(500).json({\n      message: \"Erreur serveur\"\n    });\n  }\n};\nexports.getProfile = async (req, res) => {\n  try {\n    const user = await User.findById(req.user.userId).select('-password');\n    if (!user) {\n      return res.status(404).json({\n        message: 'Utilisateur non trouvé'\n      });\n    }\n    res.status(200).json(user);\n  } catch (error) {\n    console.error('Erreur serveur:', error.message);\n    res.status(500).json({\n      message: 'Erreur serveur'\n    });\n  }\n};\n\n// Middleware pour vérifier le token JWT\nexports.authenticateToken = (req, res, next) => {\n  const token = req.header('Authorization').replace('Bearer ', '');\n  if (!token) {\n    return res.status(401).json({\n      message: 'Accès refusé, aucun token fourni'\n    });\n  }\n  try {\n    const verified = jwt.verify(token, process.env.JWT_SECRET);\n    req.user = verified;\n    next();\n  } catch (error) {\n    res.status(400).json({\n      message: 'Token invalide'\n    });\n  }\n};","map":{"version":3,"names":["User","require","bcrypt","jwt","multer","path","storage","diskStorage","destination","req","file","cb","filename","Date","now","extname","originalname","upload","exports","register","single","res","name","email","password","confirmPassword","body","status","json","message","user","findOne","trim","salt","genSalt","hashedPassword","hash","profileImage","save","token","sign","userId","_id","process","env","JWT_SECRET","expiresIn","error","console","login","log","isMatch","compare","err","getProfile","findById","select","authenticateToken","next","header","replace","verified","verify"],"sources":["C:/Users/Dell/expense-tracker_fullstack/frontend/src/Components/auth/login.js"],"sourcesContent":["const User = require('../models/user');\r\nconst bcrypt = require('bcrypt');\r\nconst jwt = require('jsonwebtoken');\r\nconst multer = require('multer');\r\nconst path = require('path');\r\n\r\n// Configuration de multer pour gérer les uploads\r\nconst storage = multer.diskStorage({\r\n  destination: function (req, file, cb) {\r\n    cb(null, 'uploads/'); // Dossier où les images seront stockées\r\n  },\r\n  filename: function (req, file, cb) {\r\n    cb(null, Date.now() + path.extname(file.originalname)); // Nom unique pour chaque fichier\r\n  }\r\n});\r\n\r\nconst upload = multer({ storage: storage });\r\n\r\nexports.register = [\r\n  upload.single('profile'), // Middleware pour gérer l'upload de l'image de profil\r\n  async (req, res) => {\r\n    const { name, email, password, confirmPassword } = req.body;\r\n\r\n    // Validation des champs\r\n    if (!name || !email || !password || !confirmPassword) {\r\n      return res.status(400).json({ message: 'Tous les champs sont requis' });\r\n    }\r\n\r\n    // Validation des mots de passe\r\n    if (password !== confirmPassword) {\r\n      return res.status(400).json({ message: 'Les mots de passe ne correspondent pas' });\r\n    }\r\n\r\n    try {\r\n      // Vérification si l'utilisateur existe déjà\r\n      let user = await User.findOne({ email: email.trim() });\r\n      if (user) {\r\n        return res.status(400).json({ message: 'Utilisateur déjà existant' });\r\n      }\r\n\r\n      // Hachage du mot de passe avant de sauvegarder l'utilisateur\r\n      const salt = await bcrypt.genSalt(10);\r\n      const hashedPassword = await bcrypt.hash(password.trim(), salt);\r\n\r\n      // Création d'un nouvel utilisateur\r\n      user = new User({\r\n        name,\r\n        email: email.trim(),\r\n        password: hashedPassword, // Utilisation du mot de passe haché\r\n        profileImage: req.file ? req.file.filename : null // Stocke le nom du fichier de l'image de profil\r\n      });\r\n\r\n      await user.save();\r\n\r\n      // Génération du token JWT\r\n      const token = jwt.sign({ userId: user._id }, process.env.JWT_SECRET, {\r\n        expiresIn: '1h'\r\n      });\r\n\r\n      res.status(201).json({ token, message: 'Inscription réussie' });\r\n    } catch (error) {\r\n      console.error(error.message);\r\n      res.status(500).json({ message: 'Erreur serveur' });\r\n    }\r\n  }\r\n];\r\n\r\nexports.login = async (req, res) => {\r\n  try {\r\n      console.log('Données reçues pour la connexion:', req.body); // Log les données reçues\r\n\r\n      const { email, password } = req.body;\r\n\r\n      // Vérifier si l'utilisateur existe\r\n      const user = await User.findOne({ email: email.trim() });\r\n      console.log('Utilisateur trouvé:', user); // Log l'utilisateur trouvé\r\n\r\n      if (!user) {\r\n          return res.status(400).json({ message: \"Email incorrect\" });\r\n      }\r\n\r\n      // Vérifier si le mot de passe est correct\r\n      const isMatch = await bcrypt.compare(password.trim(), user.password);\r\n      console.log('Résultat de la comparaison du mot de passe:', isMatch); // Log le résultat de la comparaison\r\n\r\n      if (!isMatch) {\r\n          return res.status(400).json({ message: \"Mot de passe incorrect\" });\r\n      }\r\n\r\n      // Générer un token JWT pour l'utilisateur authentifié\r\n      const token = jwt.sign({ userId: user._id }, process.env.JWT_SECRET, {\r\n        expiresIn: '1h'\r\n      });\r\n\r\n      res.status(200).json({ message: \"Login réussi\", token });\r\n  } catch (err) {\r\n      console.error('Erreur lors de la connexion:', err);\r\n      res.status(500).json({ message: \"Erreur serveur\" });\r\n  }\r\n};\r\n\r\nexports.getProfile = async (req, res) => {\r\n  try {\r\n    const user = await User.findById(req.user.userId).select('-password');\r\n    if (!user) {\r\n      return res.status(404).json({ message: 'Utilisateur non trouvé' });\r\n    }\r\n    res.status(200).json(user);\r\n  } catch (error) {\r\n    console.error('Erreur serveur:', error.message);\r\n    res.status(500).json({ message: 'Erreur serveur' });\r\n  }\r\n};\r\n\r\n// Middleware pour vérifier le token JWT\r\nexports.authenticateToken = (req, res, next) => {\r\n  const token = req.header('Authorization').replace('Bearer ', '');\r\n  if (!token) {\r\n    return res.status(401).json({ message: 'Accès refusé, aucun token fourni' });\r\n  }\r\n\r\n  try {\r\n    const verified = jwt.verify(token, process.env.JWT_SECRET);\r\n    req.user = verified;\r\n    next();\r\n  } catch (error) {\r\n    res.status(400).json({ message: 'Token invalide' });\r\n  }\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}